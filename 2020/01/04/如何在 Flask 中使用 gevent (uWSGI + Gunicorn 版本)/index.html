<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>è®°å½•ç‚¹æ»´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="How to use Flask with gevent (uWSGI and Gunicorn editions) å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) December 27, 2019 at 12:00 AM Asynchronous I/O 2019/12/27 12:00 å¼‚æ­¥ IO Disclaimer: I wrote this tut">
<meta property="og:type" content="article">
<meta property="og:title" content="è®°å½•ç‚¹æ»´">
<meta property="og:url" content="https://clampist.github.io/2020/01/04/å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) /index.html">
<meta property="og:site_name" content="è®°å½•ç‚¹æ»´">
<meta property="og:description" content="How to use Flask with gevent (uWSGI and Gunicorn editions) å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) December 27, 2019 at 12:00 AM Asynchronous I/O 2019/12/27 12:00 å¼‚æ­¥ IO Disclaimer: I wrote this tut">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://iximiuz.com/flask-gevent-tutorial/gevent-vs-asyncio-google-trends.png">
<meta property="og:image" content="https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-gevent-before.png">
<meta property="og:image" content="https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-gevent-during.png">
<meta property="og:updated_time" content="2020-01-10T09:11:21.231Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="è®°å½•ç‚¹æ»´">
<meta name="twitter:description" content="How to use Flask with gevent (uWSGI and Gunicorn editions) å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) December 27, 2019 at 12:00 AM Asynchronous I/O 2019/12/27 12:00 å¼‚æ­¥ IO Disclaimer: I wrote this tut">
<meta name="twitter:image" content="https://iximiuz.com/flask-gevent-tutorial/gevent-vs-asyncio-google-trends.png">
  
    <link rel="alternate" href="/atom.xml" title="è®°å½•ç‚¹æ»´" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">è®°å½•ç‚¹æ»´</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="æœç´¢"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://clampist.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/04/å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) /" class="article-date">
  <time datetime="2020-01-04T14:48:26.750Z" itemprop="datePublished">2020-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>How to use Flask with gevent (uWSGI and Gunicorn editions)</p>
<p>å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬)</p>
<p>December 27, 2019 at 12:00 AM Asynchronous I/O</p>
<p>2019/12/27 12:00 å¼‚æ­¥ IO</p>
<p>Disclaimer: I wrote this tutorial because gevent saved our project a few years ago and I still see steady gevent-related search traffic on my blog. So, the way gevent helped us may be useful for somebody else as well. Since I still have some handy knowledge I decided to make this note on how to set up things. However, Iâ€™d not advise starting a new project in 2020 using this technology. IMHO, itâ€™s aging and losing the traction.</p>
<p>å…è´£å£°æ˜ï¼šæˆ‘å½“æ—¶å†™è¿™ç¯‡æ•™ç¨‹æ˜¯å› ä¸ºå‡ å¹´å‰ gevent æ‹¯æ•‘äº†æˆ‘ä»¬çš„é¡¹ç›®ï¼Œå¹¶ä¸”åœ¨æˆ‘çš„åšå®¢ä¸Šä»èƒ½çœ‹åˆ°æœ‰å…³ gevent çš„ç¨³å®šæœç´¢æµé‡ã€‚æ‰€ä»¥ gevent å¸®åŠ©æˆ‘ä»¬çš„æ–¹å¼å¯èƒ½å¯¹å…¶ä»–äººä¹Ÿæœ‰ç”¨ï¼Œå› æ­¤æˆ‘å†³å®šæ¥è®°å½•ä¸‹å…¶å®ç”¨çš„è®¾ç½®ã€‚ç„¶è€Œï¼Œæˆ‘ä¸å»ºè®®åœ¨2020å¹´æœ‰æ–°é¡¹ç›®è¿˜ä½¿ç”¨è¿™é¡¹æŠ€æœ¯ï¼Œä¾æœ¬äººæ„šè§ï¼Œå®ƒæ­£åœ¨è€åŒ–ï¼Œå¤±å»äº†å¸å¼•åŠ›ã€‚</p>
<p>TL;DR: check out code samples on GitHub.</p>
<p>å¤ªé•¿ä¸çœ‹ï¼šåœ¨ Github ä¸ŠæŸ¥çœ‹ä»£ç ç¤ºä¾‹</p>
<p>Python is booming and Flask is a pretty popular web-framework nowadays. Probably, quite some new projects are being started in Flask. But people should be aware, itâ€™s synchronous by design and ASGI is not a thing yet. So, if someday you realize that your project really needs asynchronous I/O but you already have a considerable codebase on top of Flask, this tutorial is for you. The charming gevent library will enable you to keep using Flask while start benefiting from all the I/O being asynchronous. In the tutorial we will see:</p>
<p>å¦‚ä»Š Python çˆ†ç‚¸å¼å¢é•¿ï¼ŒFlask ä½œä¸ºä¸€ä¸ªç›¸å½“å—æ¬¢è¿çš„ Web æ¡†æ¶ï¼Œæˆ–è®¸ï¼Œè®¸å¤šæ–°é¡¹ç›®éƒ½é‡‡ç”¨äº† Flaskã€‚ä½†æ˜¯äººä»¬åº”è¯¥çŸ¥æ™“ï¼ŒåŒæ­¥è®¾è®¡å’Œ ASGI è¿˜ä¸æˆæ°”å€™ã€‚å› æ­¤å¦‚æœæŸå¤©ä½ æ„è¯†åˆ°ä½ çš„é¡¹ç›®ç¡®å®éœ€è¦å¼‚æ­¥ I/Oï¼Œå¹¶ä¸”ä½ å·²ç»åœ¨ Flask æœ‰æœ€å¤šçš„ä»£ç åŸºå‡†ï¼Œçœ‹è¿™ç¯‡æ•™ç¨‹å°±å¯¹äº†ã€‚æ˜æ˜Ÿåº“ gevent å°†è®©ä½ åœ¨æŒç»­ä½¿ç”¨Flaskæ—¶ä»å…¨å¼‚æ­¥ I/O å—ç›Šã€‚åœ¨è¿™ç¯‡æ•™ç¨‹ä¸­å¯ä»¥çœ‹åˆ°ï¼š</p>
<ul>
<li>How to monkey patch a Flask app to make it asynchronous w/o changing its code.</li>
<li>How to run the patched application using gevent.pywsgi application server.</li>
<li>How to run the patched application using Gunicorn application server.</li>
<li>How to run the patched application using uWSGI application server.</li>
<li>How to configure Nginx proxy in front of the application server.</li>
<li><p>[Bonus] How to use psycopg2 with psycogreen to make PostgreSQL access non-blocking.</p>
</li>
<li><p>å¦‚ä½•ä¿®æ”¹ä»£ç ç»™ Flask åº”ç”¨æ‰“ çŒ´å­è¡¥ä¸ æ¥è®©å®ƒæ”¯æŒå¼‚æ­¥ I/O</p>
</li>
<li>å¦‚ä½•è¿è¡Œæ‰“è¿‡è¡¥ä¸ä½¿ç”¨ gevent.pywsgi åº”ç”¨æœåŠ¡å™¨çš„åº”ç”¨</li>
<li>å¦‚ä½•è¿è¡Œæ‰“è¿‡è¡¥ä¸ä½¿ç”¨ Gunicorn åº”ç”¨æœåŠ¡å™¨çš„åº”ç”¨</li>
<li>å¦‚ä½•è¿è¡Œæ‰“è¿‡è¡¥ä¸ä½¿ç”¨ uWSGI åº”ç”¨æœåŠ¡å™¨çš„åº”ç”¨</li>
<li>å¦‚ä½•é…ç½®åº”ç”¨æœåŠ¡å™¨å‰çš„ Nginx ä»£ç†</li>
<li>[ç¦åˆ©] å¦‚ä½•å°† psycopg2 ä¸ psycogreen ä¸€èµ·ä½¿ç”¨ï¼Œæ¥éé˜»å¡è®¿é—® PostgreSQL</li>
</ul>
<h1 id="1-When-do-I-need-asynchronous-I-O"><a href="#1-When-do-I-need-asynchronous-I-O" class="headerlink" title="1. When do I need asynchronous I/O"></a>1. When do I need asynchronous I/O</h1><p>The answer is somewhat naive - you need it when the applicationâ€™s workload is I/O bound, i.e. it maxes out on latency SLI due to over-communicating to external services. Itâ€™s a pretty common situation nowadays due to the enormous spread of microservice architectures and various 3rd-party APIs. If an average HTTP handler in your application needs to make 10+ network requests to build a response, itâ€™s highly likely that you will benefit from asynchronous I/O. On the other hand, if your application consumes 100% of CPU or RAM handling requests, migrating to asynchronous I/O probably will not help.</p>
<h1 id="1-ä»€ä¹ˆæ—¶å€™éœ€æ±‚å¼‚æ­¥-I-O"><a href="#1-ä»€ä¹ˆæ—¶å€™éœ€æ±‚å¼‚æ­¥-I-O" class="headerlink" title="1. ä»€ä¹ˆæ—¶å€™éœ€æ±‚å¼‚æ­¥ I/O"></a>1. ä»€ä¹ˆæ—¶å€™éœ€æ±‚å¼‚æ­¥ I/O</h1><p>ç­”æ¡ˆæœ‰äº›å¹¼ç¨š â€” å½“åº”ç”¨çš„å·¥ä½œè´Ÿè½½å— I/O é™åˆ¶æ—¶å°±éœ€è¦å®ƒï¼Œå³ç”±äºä¸å¤–éƒ¨æœåŠ¡çš„è¿‡åº¦é€šä¿¡ï¼Œå®ƒæœ€å¤§ç¨‹åº¦åœ°å¢åŠ äº†å»¶è¿Ÿ SLI (service level indicatorsï¼Œå³æœåŠ¡æ°´å¹³æŒ‡æ ‡)ã€‚ç”±äºå¾®æœåŠ¡æ¶æ„å’Œå„ç§ç¬¬ä¸‰æ–¹APIçš„å¹¿æ³›ä¼ æ’­ï¼Œå¦‚ä»Šè¿™æ˜¯ä¸€ç§éå¸¸æ™®éçš„æƒ…å†µã€‚å¦‚æœä½ çš„åº”ç”¨ä¸­å¹³å‡æ¯ä¸ª HTTP Handler éœ€è¦è°ƒç”¨ 10 æ¬¡ä»¥ä¸Šçš„ç½‘ç»œè¯·æ±‚æ¥ç”Ÿæˆå“åº”ï¼Œé‚£ä¹ˆä½ å°±å¾ˆæœ‰å¯èƒ½å°†ä»å¼‚æ­¥ I/O ä¸­å—ç›Šã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœä½ çš„åº”ç”¨æ¶ˆè€— 100ï¼… çš„ CPU æˆ– RAM æ¥å¤„ç†è¯·æ±‚ï¼Œé‚£ä¹ˆè¿ç§»åˆ°å¼‚æ­¥ I/O å¯èƒ½æ— æµäºäº‹ã€‚</p>
<h1 id="2-What-is-gevent"><a href="#2-What-is-gevent" class="headerlink" title="2. What is gevent"></a>2. What is gevent</h1><h1 id="2-gevent-æ˜¯ä»€ä¹ˆ"><a href="#2-gevent-æ˜¯ä»€ä¹ˆ" class="headerlink" title="2. gevent æ˜¯ä»€ä¹ˆ"></a>2. gevent æ˜¯ä»€ä¹ˆ</h1><p>From the official site description:</p>
<p>æ¥è‡ªå®˜æ–¹ç«™ç‚¹çš„æè¿°ï¼š</p>
<p>gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop.</p>
<p>gevent æ˜¯ä¸€ä¸ªåŸºäºåç¨‹çš„ Python ç½‘ç»œåº“ï¼Œå®ƒä½¿ç”¨ greenlet åœ¨ libev æˆ– libuv äº‹ä»¶å¾ªç¯çš„é¡¶å±‚æä¾›é«˜çº§åŒæ­¥ APIã€‚</p>
<p>The description is rather obscure for those who are unfamiliar with the mentioned dependencies like greenlet, libev, or libuv. You can check out my previous attempt to briefly explain the nature of this library, but among other things it allows you to monkey patch normal-looking Python code and make the underlying I/O happening asynchronously. The patching introduces whatâ€™s called cooperative multitasking into the Python standard library and some 3rd-party modules but the change stays almost completely hidden from the application and the existing code keeps its synchronous-alike outlook while gains the ability to serve requests asynchronously. There is an obvious downside of this approach - the patching doesnâ€™t change the way every single HTTP request is being served, i.e. the I/O within each HTTP handler still happens sequentially, even though it becomes asynchronous. Well, we can start using something similar to asyncio.gather() and parallelize some requests to external resources, but it would require the modification of the existing application code. However, now we can easily scale up the limit of concurrent HTTP requests for our application. After the patching, we donâ€™t need a dedicated thread (or process) per request anymore. Instead, each request handling now happens in a lightweight green thread. Thus, the application can serve tens of thousands of concurrent requests, probably increasing this number by 1-2 orders of magnitude from the previous limit.</p>
<p>å¯¹äºé‚£äº›ä¸ç†Ÿæ‚‰æ‰€æåŠä¾èµ–é¡¹ï¼ˆä¾‹å¦‚greenletï¼Œlibevæˆ–libuvï¼‰çš„äººæ¥è¯´ï¼Œè¿™ä¸ªæè¿°æ˜¯ç›¸å½“æ™¦æ¶©çš„ã€‚ä½ å¯ä»¥æŸ¥çœ‹æˆ‘å…ˆå‰çš„ç®€è¦è§£é‡Šï¼Œä½†é™¤æ­¤ä¹‹å¤–ï¼Œé€šè¿‡æ‰“ çŒ´å­è¡¥ä¸ èƒ½è®©çœ‹ä¸Šå»å¾ˆæ™®é€šçš„ Python ä»£ç åœ¨åº•å±‚å®ç°å¼‚æ­¥ I/Oã€‚è¡¥ä¸ç¨‹åº å°†æ‰€è°“çš„åä½œå¼å¤šä»»åŠ¡å¤„ç†å¼•å…¥äº† Python æ ‡å‡†åº“å’Œä¸€äº›ç¬¬ä¸‰æ–¹æ¨¡å—ä¸­ï¼Œä½†æ˜¯å‡ ä¹å®Œå…¨éšè—åº”ç”¨ç¨‹åºä¸­çš„æ”¹åŠ¨ï¼Œç°æœ‰ä»£ç ä¿æŒç±»ä¼¼åŒæ­¥çš„å¤–è§‚ï¼ŒåŒæ—¶å…·æœ‰å¼‚æ­¥å¤„ç†è¯·æ±‚çš„èƒ½åŠ›ã€‚è¿™ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ˜æ˜¾çš„ç¼ºç‚¹ â€” è¡¥ä¸ä¸ä¼šæ”¹å˜æ¯ä¸ª HTTP è¯·æ±‚è¢«æä¾›æœåŠ¡çš„æ–¹å¼ï¼Œå³æ¯ä¸ª HTTP Handler ä¸­çš„ I/O ä»ç„¶æ˜¯é¡ºåºæ‰§è¡Œï¼Œå³ä½¿å®ƒå˜æˆäº†å¼‚æ­¥ã€‚å¥½äº†ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹ä½¿ç”¨ç±»ä¼¼äº asyncio.gather() çš„ä¸œè¥¿ï¼Œå¹¶å°†ä¸€äº›è¯·æ±‚å¹¶è¡ŒåŒ–åˆ°å¤–éƒ¨èµ„æºï¼Œä½†è¿™å°†éœ€è¦ä¿®æ”¹ç°æœ‰çš„åº”ç”¨ç¨‹åºä»£ç ã€‚ç„¶è€Œï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥è½»æ¾æ‰©å±•åº”ç”¨çš„ HTTP å¹¶å‘è¯·æ±‚çš„é™åˆ¶ã€‚æ‰“å®Œè¡¥ä¸åï¼Œæˆ‘ä»¬ä¸å†éœ€è¦æ¯ä¸ªè¯·æ±‚ä¸€ä¸ªä¸“ç”¨çº¿ç¨‹ï¼ˆæˆ–è¿›ç¨‹ï¼‰ã€‚ç›¸åï¼Œç°åœ¨æ¯ä¸ªè¯·æ±‚å¤„ç†éƒ½åœ¨è½»é‡çº§ç»¿è‰²çº¿ç¨‹ä¸­è¿›è¡Œã€‚å› æ­¤ï¼Œè¯¥åº”ç”¨ç¨‹åºå¯ä»¥å¤„ç†æˆåƒä¸Šä¸‡çš„å¹¶å‘è¯·æ±‚ï¼Œå¯èƒ½è®©å¹¶å‘æ•°é™åˆ¶æ¯”ä¹‹å‰å¢åŠ 1-2ä¸ªæ•°é‡çº§ã€‚</p>
<p>However, while the description sounds extremely promising (at least to me), the project and the surrounding eco-system is steadily losing traction (in favor of asyncio and aiohttp?):</p>
<p>ä½†æ˜¯ï¼Œå°½ç®¡è¿™ä¸ªæè¿°å¬èµ·æ¥éå¸¸æœ‰å‰é€”ï¼ˆè‡³å°‘å¯¹æˆ‘æ¥è¯´ï¼‰ï¼Œä½†æ˜¯è¿™ä¸ªé¡¹ç›®å’Œå®ƒå‘¨å›´çš„ç”Ÿæ€ç³»ç»Ÿæ­£åœ¨é€æ¸å¤±å»å¸å¼•åŠ›ï¼ˆèµæˆä½¿ç”¨ asyncio å’Œ aiohttpï¼Ÿï¼‰ï¼š</p>
<p><img src="https://iximiuz.com/flask-gevent-tutorial/gevent-vs-asyncio-google-trends.png" alt="gevent vs asyncio google trends"></p>
<h1 id="3-Create-simple-Flask-application"><a href="#3-Create-simple-Flask-application" class="headerlink" title="3. Create simple Flask application"></a>3. Create simple Flask application</h1><h1 id="3-åˆ›å»º-Flask-å•åº”ç”¨"><a href="#3-åˆ›å»º-Flask-å•åº”ç”¨" class="headerlink" title="3. åˆ›å»º Flask å•åº”ç”¨"></a>3. åˆ›å»º Flask å•åº”ç”¨</h1><p>The standard tutorial format always seemed boring to me. Instead, we will try to make a tiny playground here. We will try to create a simple Flask application dependant on a sleepy 3rd party API endpoint. The only route of our application will be responding with some hard-coded string concatenated with the API response text. Having such a workload, we will play with different methods of achieving high concurrency in the Flaskâ€™s handling of HTTP requests.</p>
<p>å¯¹æˆ‘æ¥è¯´æ ¼å¼åŒ–çš„æ ‡å‡†æ•™ç¨‹æ€»æ˜¯å¾ˆæ— èŠã€‚ç›¸åï¼Œæˆ‘ä»¬å°†å°è¯•åœ¨æ­¤å»ºç«‹ä¸€ä¸ªå°å‹æ¸¸ä¹åœºã€‚æˆ‘ä»¬å°†å°è¯•åˆ›å»ºä¸€ä¸ªåŸºäºç¬¬ä¸‰æ–¹ API ç«¯ç‚¹çš„ç®€å• Flask ç¡çœ åº”ç”¨ã€‚æˆ‘ä»¬åº”ç”¨çš„å”¯ä¸€é€”å¾„æ˜¯å°† API å“åº”æ–‡æœ¬ä¸ç¡¬ç¼–ç å­—ç¬¦ä¸²è¿æ¥èµ·æ¥ä½œä¸ºå“åº”ã€‚åŸºäºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸åŒçš„æ–¹æ³•æ¥å®ç° Flask å¤„ç† HTTP è¯·æ±‚çš„é«˜å¹¶å‘æ€§ã€‚</p>
<p>First, we need to emulate a slow 3rd party API. We will use aiohttp to implement it because itâ€™s based on the asyncio library and provides high concurrency for I/O-bound HTTP requests handling out of the box:</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿä¸€ä¸ªæ…¢çš„ç¬¬ä¸‰æ–¹ APIã€‚æˆ‘ä»¬å°†ä½¿ç”¨ aiohttp æ¥å®ç°å®ƒï¼Œå› ä¸ºå®ƒåŸºäºasyncioåº“ï¼Œå¹¶ä¸”å¼€ç®±å³ç”¨åœ°ä¸º I/O ç»‘å®š HTTPè¯·æ±‚ æä¾›äº†é«˜å¹¶å‘æ€§ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ./slow_api/api.py</div><div class="line">import os</div><div class="line">import asyncio</div><div class="line">from aiohttp import web</div><div class="line"></div><div class="line">async def handle(request):</div><div class="line">    delay = float(request.query.get(&apos;delay&apos;) or 1)</div><div class="line">    await asyncio.sleep(delay)</div><div class="line">    return web.Response(text=&apos;slow api response&apos;)</div><div class="line"></div><div class="line">app = web.Application()</div><div class="line">app.add_routes([web.get(&apos;/&apos;, handle)])</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    web.run_app(app, port=os.environ[&apos;PORT&apos;])</div></pre></td></tr></table></figure>
<p>We can launch it in the following Docker container:</p>
<p>æˆ‘ä»¬å¯ä»¥åœ¨ä»¥ä¸‹ Docker å®¹å™¨ä¸­å¯åŠ¨å®ƒï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ./slow_api/Dockerfile</div><div class="line">FROM python:3.8</div><div class="line"></div><div class="line">RUN pip install aiohttp</div><div class="line"></div><div class="line">COPY api.py /api.py</div><div class="line"></div><div class="line">CMD [&quot;python&quot;, &quot;/api.py&quot;]</div></pre></td></tr></table></figure>
<p>Now, itâ€™s time to create the target Flask application:</p>
<p>ç°åœ¨ï¼Œæ˜¯æ—¶å€™åˆ›å»ºç›®æ ‡ Flask åº”ç”¨äº†ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"># ./flask_app/app.py</div><div class="line">import os</div><div class="line">import requests</div><div class="line">from flask import Flask, request</div><div class="line"></div><div class="line">api_port = os.environ[&apos;PORT_API&apos;]</div><div class="line">api_url = f&apos;http://slow_api:&#123;api_port&#125;/&apos;</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    delay = float(request.args.get(&apos;delay&apos;) or 1)</div><div class="line">    resp = requests.get(f&apos;&#123;api_url&#125;?delay=&#123;delay&#125;&apos;)</div><div class="line">    return &apos;Hi there! &apos; + resp.text</div><div class="line">```    </div><div class="line"></div><div class="line">As promised, it&apos;s fairly simple.</div><div class="line"></div><div class="line">å¦‚æ‰€æ‰¿è¯ºçš„ï¼Œè¿™éå¸¸ç®€å•ã€‚</div><div class="line"></div><div class="line"># 4. Deploy Flask application using Flask dev server</div><div class="line"></div><div class="line"># 4. ä½¿ç”¨ Flask å¼€å‘æœåŠ¡å™¨éƒ¨ç½² Flask åº”ç”¨</div><div class="line"></div><div class="line">The easiest way to run a Flask application is to use a built-in development server. But even this beast supports two modes of request handling.</div><div class="line"></div><div class="line">è¿è¡Œ Flask åº”ç”¨ç¨‹åºçš„æœ€ç®€å•æ–¹æ³•æ˜¯ä½¿ç”¨å†…ç½®çš„å¼€å‘æœåŠ¡å™¨ã€‚ ä½†æ˜¯ï¼Œå³ä½¿è¿™ç§æœ€åŸå§‹çš„æ–¹å¼ä¹Ÿæ”¯æŒä¸¤ç§è¯·æ±‚å¤„ç†æ¨¡å¼ã€‚</div><div class="line"></div><div class="line">In the single-threaded mode, a Flask application can handle no more than one HTTP request at a time. I.e. the request handling becomes sequential.</div><div class="line"></div><div class="line">åœ¨å•çº¿ç¨‹æ¨¡å¼ä¸‹ï¼ŒFlask åº”ç”¨ç¨‹åºä¸€æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ª HTTP è¯·æ±‚ã€‚ å³è¯·æ±‚å¤„ç†æ˜¯é¡ºåºçš„ã€‚</div><div class="line"></div><div class="line">Experience ğŸ¤¦</div><div class="line">In the multi-threaded mode, Flask spawns a thread for every incoming HTTP request. The maximal concurrency, i.e. the highest possible number of simultaneous threads doesn&apos;t seem configurable though.</div><div class="line"></div><div class="line">ä½“éªŒğŸ¤¦</div><div class="line">åœ¨å¤šçº¿ç¨‹æ¨¡å¼ä¸‹ï¼ŒFlask ä¸ºæ¯ä¸ªä¼ å…¥çš„ HTTP è¯·æ±‚ç”Ÿæˆä¸€ä¸ªçº¿ç¨‹ã€‚ ä¸è¿‡ï¼Œæœ€å¤§å¹¶å‘æ€§ï¼ˆå³å¹¶å‘çº¿ç¨‹çš„æœ€å¤§æ•°é‡ï¼‰ä¼¼ä¹æ˜¯ä¸å¯é…ç½®çš„ã€‚</div><div class="line"></div><div class="line">We will use the following Dockerfile to run the Flask dev server:</div><div class="line"></div><div class="line">æˆ‘ä»¬å°†ä½¿ç”¨ä»¥ä¸‹ Dockerfile è¿è¡Œ Flask å¼€å‘æœåŠ¡å™¨ï¼š</div></pre></td></tr></table></figure>
<h1 id="flask-app-Dockerfile-devserver"><a href="#flask-app-Dockerfile-devserver" class="headerlink" title="./flask_app/Dockerfile-devserver"></a>./flask_app/Dockerfile-devserver</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests</p>
<p>COPY app.py /app.py</p>
<p>ENV FLASK_APP=app</p>
<p>CMD flask run â€“no-reload \<br>  â€“$THREADS-threads \<br>  â€“host 0.0.0.0 â€“port $PORT_APP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">Let&apos;s spin up the first playground using handy Docker Compose:</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬ä½¿ç”¨æ–¹ä¾¿çš„ Docker Compose æ‰“é€ ç¬¬ä¸€ä¸ªæ¸¸ä¹åœºï¼š</div></pre></td></tr></table></figure></p>
<h1 id="sync-devserver-yml"><a href="#sync-devserver-yml" class="headerlink" title="./sync-devserver.yml"></a>./sync-devserver.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-devserver<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - THREADS=without
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  flask_app_threaded: # extends: flask_app<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-devserver<br>    environment:</p>
<pre><code>  - PORT_APP=3001
  - PORT_API=4000
  - THREADS=with
ports:
  - &quot;127.0.0.1:3001:3001&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">After running docker-compose build and docker-compose up we will have two instances of our application running. The single-threaded version is bound to the host&apos;s 127.0.0.1:3000, the multi-threaded - to 127.0.0.1:3001.</div><div class="line"></div><div class="line">åœ¨è¿è¡Œ docker-compose build å’Œ docker-compose up ä¹‹åï¼Œæˆ‘ä»¬çš„åº”ç”¨å°†æœ‰ä¸¤ä¸ªå®ä¾‹åœ¨è¿è¡Œã€‚å•çº¿ç¨‹ç‰ˆæœ¬ç»‘å®šåœ¨ 127.0.0.1:3000ï¼Œå¤šçº¿ç¨‹ç»‘å®šåœ¨ 127.0.0.1:3001ã€‚</div></pre></td></tr></table></figure>
<h1 id="Build-and-start-app-served-by-Flask-dev-server"><a href="#Build-and-start-app-served-by-Flask-dev-server" class="headerlink" title="Build and start app served by Flask dev server"></a>Build and start app served by Flask dev server</h1><p>$ docker-compose -f sync-devserver.yml build<br>$ docker-compose -f sync-devserver.yml up<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">It&apos;s time to serve the first portion of HTTP requests (using lovely ApacheBench). We will start from the single-threaded version and only 10 requests:</div><div class="line"></div><div class="line">ç°åœ¨è¯¥ä¸º HTTP ç¬¬ä¸€éƒ¨åˆ†çš„è¯·æ±‚æä¾›æœåŠ¡äº†ï¼ˆä½¿ç”¨å¯çˆ±çš„ApacheBenchï¼‰ã€‚æˆ‘ä»¬å°†ä»å•çº¿ç¨‹ç‰ˆæœ¬å¼€å§‹ï¼Œåªæœ‰10ä¸ªè¯·æ±‚ï¼š</div></pre></td></tr></table></figure></p>
<h1 id="Test-single-threaded-deployment"><a href="#Test-single-threaded-deployment" class="headerlink" title="Test single-threaded deployment"></a>Test single-threaded deployment</h1><p>$ ab -r -n 10 -c 5 <a href="http://127.0.0.1:3000/?delay=1" target="_blank" rel="external">http://127.0.0.1:3000/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      5<br>Time taken for tests:   10.139 seconds<br>Complete requests:      10<br>Failed requests:        0<br>Requests per second:    0.99 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">As expected, we observed no concurrency. Even though we asked ab to simulate 5 simultaneous clients using -c 5, it took ~10 seconds to finish the scenario with an effective request rate close to 1 per second.</div><div class="line"></div><div class="line">å¦‚é¢„æœŸçš„é‚£æ ·ï¼Œæˆ‘ä»¬æ²¡æœ‰å‘ç°å¹¶å‘ã€‚ å³ä½¿æˆ‘ä»¬ä½¿ç”¨ab -c 5 æ¨¡æ‹Ÿ 5 ä¸ªå¹¶å‘å®¢æˆ·ç«¯ï¼Œä½†å®ƒè¿˜æ˜¯èŠ±è´¹äº†å¤§çº¦ 10 ç§’é’Ÿæ‰ä»¥ 1ç§’1ä¸ª çš„æ•ˆç‡å®Œæˆè¯¥åœºæ™¯ã€‚</div><div class="line"></div><div class="line">If you execute top -H in the server container to check the number of running threads, the picture will be similar to this:</div><div class="line"></div><div class="line">å¦‚æœåœ¨æœåŠ¡å™¨å®¹å™¨ä¸­æ‰§è¡Œtop -Hæ¥æ£€æŸ¥æ­£åœ¨è¿è¡Œçš„çº¿ç¨‹æ•°ï¼Œåˆ™å›¾ç‰‡å°†ç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š</div><div class="line"></div><div class="line">![deploy-devserver](https://iximiuz.com/flask-gevent-tutorial/deploy-devserver.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_1 top -H`</div><div class="line"></div><div class="line">Let&apos;s proceed to the multi-threaded version alongside with increasing the payload up to 2000 requests being produced by 200 simultaneous clients:</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬ç»§ç»­è¿›è¡Œå¤šçº¿ç¨‹ç‰ˆæœ¬ï¼ŒåŒæ—¶å°†æœ‰æ•ˆè´Ÿè½½å¢åŠ åˆ°200ä¸ªå¹¶å‘å®¢æˆ·ç«¯ï¼Œå¹¶äº§ç”Ÿçš„2000ä¸ªè¯·æ±‚ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="Test-multi-threaded-deployment"><a href="#Test-multi-threaded-deployment" class="headerlink" title="Test multi-threaded deployment"></a>Test multi-threaded deployment</h1><p>$ ab -r -n 2000 -c 200 <a href="http://127.0.0.1:3001/?delay=1" target="_blank" rel="external">http://127.0.0.1:3001/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      200<br>Time taken for tests:   16.040 seconds<br>Complete requests:      2000<br>Failed requests:        0<br>Requests per second:    124.69 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">The effective concurrency grew to the mean of 124 requests per second, but a sample from top -H shows, that at some point of time we had 192 threads and 190 of them were sleeping:</div><div class="line"></div><div class="line">æœ‰æ•ˆå¹¶å‘å¢é•¿åˆ°å¹³å‡æ¯ç§’124ä¸ªè¯·æ±‚ï¼Œä½†æ˜¯top -Hçš„æ ·æœ¬æ˜¾ç¤ºï¼Œåœ¨æŸä¸ªæ—¶é—´ç‚¹ï¼Œæˆ‘ä»¬æœ‰192ä¸ªçº¿ç¨‹ï¼Œå…¶ä¸­190ä¸ªæ­£åœ¨ä¼‘çœ ï¼š</div><div class="line"></div><div class="line">![deploy-devserver-threaded](https://iximiuz.com/flask-gevent-tutorial/deploy-devserver-threaded.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_threaded_1 top -H`</div><div class="line"></div><div class="line"># 5. Deploy Flask application using gevent.pywsgi</div><div class="line"></div><div class="line"># 5. ä½¿ç”¨ gevent.pywsgi éƒ¨ç½² Flask åº”ç”¨</div><div class="line"></div><div class="line">The fastest way to unleash the power of gevent is to use its built-in WSGI-server called gevent.pywsgi.</div><div class="line"></div><div class="line">é‡Šæ”¾ gevent å¨åŠ›çš„æœ€å¿«æ–¹æ³•æ˜¯ä½¿ç”¨å…¶å†…ç½®çš„ WSGI æœåŠ¡å™¨ gevent.pywsgiã€‚</div><div class="line"></div><div class="line">We need to create an entrypoint:</div><div class="line"></div><div class="line">æˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªå…¥å£ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="flask-app-pywsgi-py"><a href="#flask-app-pywsgi-py" class="headerlink" title="./flask_app/pywsgi.py"></a>./flask_app/pywsgi.py</h1><p>from gevent import monkey<br>monkey.patch_all()</p>
<p>import os<br>from gevent.pywsgi import WSGIServer<br>from app import app</p>
<p>http_server = WSGIServer((â€˜0.0.0.0â€™, int(os.environ[â€˜PORT_APPâ€™])), app)<br>http_server.serve_forever()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Notice, how it patches our Flask application. Without monkey.patch_all() there would be no benefit from using gevent here because all the I/O in the application stayed synchronous.</div><div class="line"></div><div class="line">æ³¨æ„ï¼Œå®ƒæ˜¯å¦‚ä½•ç»™æˆ‘ä»¬çš„ Flask åº”ç”¨æ‰“è¡¥ä¸çš„ã€‚ å¦‚æœæ²¡æœ‰ monkey.patch_all()ï¼Œåœ¨è¿™é‡Œä½¿ç”¨geventå°†æ— æµäºäº‹ï¼Œå› ä¸ºåº”ç”¨ä¸­çš„æ‰€æœ‰ I/O ä»ç„¶æ˜¯åŒæ­¥çš„ã€‚</div><div class="line"></div><div class="line">The following Dockerfile can be used to run the pywsgi server:</div><div class="line"></div><div class="line">ä»¥ä¸‹ Dockerfile å¯ç”¨äºè¿è¡Œ pywsgi æœåŠ¡å™¨ï¼š</div></pre></td></tr></table></figure></p>
<h1 id="flask-app-Dockerfile-gevent-pywsgi"><a href="#flask-app-Dockerfile-gevent-pywsgi" class="headerlink" title="./flask_app/Dockerfile-gevent-pywsgi"></a>./flask_app/Dockerfile-gevent-pywsgi</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests gevent</p>
<p>COPY app.py /app.py<br>COPY pywsgi.py /pywsgi.py</p>
<p>CMD python /pywsgi.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Finally, let&apos;s prepare the following playground:</div><div class="line"></div><div class="line">æœ€åï¼Œè®©æˆ‘ä»¬å‡†å¤‡å¦‚ä¸‹çš„æ¸¸ä¹åœºï¼š</div></pre></td></tr></table></figure></p>
<h1 id="async-gevent-pywsgi-yml"><a href="#async-gevent-pywsgi-yml" class="headerlink" title="./async-gevent-pywsgi.yml"></a>./async-gevent-pywsgi.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-gevent-pywsgi<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - THREADS=without
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">And launch it using:</div><div class="line"></div><div class="line">ç”¨ä¸‹é¢çš„å‘½ä»¤å¯åŠ¨ï¼š</div></pre></td></tr></table></figure>
<h1 id="Build-and-start-app-served-by-gevent-pywsgi"><a href="#Build-and-start-app-served-by-gevent-pywsgi" class="headerlink" title="Build and start app served by gevent.pywsgi"></a>Build and start app served by gevent.pywsgi</h1><p>$ docker-compose -f async-gevent-pywsgi.yml build<br>$ docker-compose -f async-gevent-pywsgi.yml up<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We expect a decent concurrency level with very few threads (if any) in the server container:</div><div class="line"></div><div class="line">æˆ‘ä»¬å¸Œæœ›è®©æœåŠ¡å™¨å®¹å™¨ä¸­çº¿ç¨‹å°½å¯èƒ½å°‘ï¼Œä»è€Œä½¿å¹¶å‘çº§åˆ«å°½å¯èƒ½é«˜ã€‚</div></pre></td></tr></table></figure></p>
<p>$ ab -r -n 2000 -c 200 <a href="http://127.0.0.1:3000/?delay=1" target="_blank" rel="external">http://127.0.0.1:3000/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      200<br>Time taken for tests:   17.536 seconds<br>Complete requests:      2000<br>Failed requests:        0<br>Requests per second:    114.05 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Executing top -H shows that we DO have some python threads (around 10). Seems like gevent employs a thread pool to implement the asynchronous I/O:</div><div class="line"></div><div class="line">æ‰§è¡Œ`top -H`è¡¨æ˜æˆ‘ä»¬ç¡®å®æœ‰ä¸€äº› python çº¿ç¨‹ï¼ˆå¤§çº¦10ä¸ªï¼‰ã€‚ä¼¼ä¹ gevent ä½¿ç”¨çº¿ç¨‹æ± æ¥å®ç°å¼‚æ­¥ I/Oï¼š</div><div class="line"></div><div class="line">![deploy-pywsgi](https://iximiuz.com/flask-gevent-tutorial/deploy-pywsgi.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_1 top -H`</div><div class="line"></div><div class="line"># 6. Deploy Flask application using Gunicorn</div><div class="line"></div><div class="line"># 6. ä½¿ç”¨ Gunicorn éƒ¨ç½² Flask åº”ç”¨</div><div class="line"></div><div class="line">Gunicorn is one of the recommended ways to run Flask applications. We will start from Gunicorn because it has slightly fewer parameters to configure before going than uWSGI.</div><div class="line"></div><div class="line">Gunicorn æ˜¯è¿è¡Œ Flask åº”ç”¨çš„æ¨èæ–¹æ³•ä¹‹ä¸€ã€‚æˆ‘ä»¬ä½¿ç”¨ Gunicorn æ˜¯å› ä¸ºä¸ uWSGI ç›¸æ¯”ï¼Œå®ƒåœ¨è¿è¡Œä¹‹å‰éœ€è¦çš„é…ç½®å‚æ•°å°‘ä¸€äº›ã€‚</div><div class="line"></div><div class="line">Gunicorn uses the worker process model to serve HTTP requests. But there are multiple types of workers: synchronous, asynchronous, tornado workers, and asyncio workers.</div><div class="line"></div><div class="line">Gunicorn ä½¿ç”¨ worker è¿›ç¨‹æ¨¡å‹æ¥ä¸º HTTP è¯·æ±‚æä¾›æœåŠ¡ã€‚ä½†å®ƒæœ‰å¤šç§ worker ç±»å‹ï¼šåŒæ­¥ workersï¼Œå¼‚æ­¥ workersï¼Œtornado workers å’Œ asyncio workersã€‚</div><div class="line"></div><div class="line">In this tutorial, we will cover only the first two types - synchronous and gevent-based asynchronous workers. Let&apos;s start from the synchronous model:</div><div class="line"></div><div class="line">åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä»…ä»‹ç»å‰ä¸¤ç§ç±»å‹ â€” åŒæ­¥å’ŒåŸºäº gevent çš„å¼‚æ­¥ workersã€‚è®©æˆ‘ä»¬ä»åŒæ­¥ workers æ¨¡å‹å¼€å§‹ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="flask-app-Dockerfile-gunicorn"><a href="#flask-app-Dockerfile-gunicorn" class="headerlink" title="./flask_app/Dockerfile-gunicorn"></a>./flask_app/Dockerfile-gunicorn</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests gunicorn</p>
<p>COPY app.py /app.py</p>
<p>CMD gunicorn â€“workers $WORKERS \<br>  â€“threads $THREADS \<br>  â€“bind 0.0.0.0:$PORT_APP \<br>  app:app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Notice that we reuse the original app.py entrypoint without any changes. The synchronous Gunicorn playground looks as follows:</div><div class="line"></div><div class="line">æ³¨æ„ï¼Œæˆ‘ä»¬æ²¡æœ‰ä»»ä½•æ›´æ”¹è€Œé‡ç”¨äº†åŸå§‹çš„ app.py å…¥å£ã€‚åŒæ­¥çš„ Gunicorn æ¸¸ä¹åœºå¦‚ä¸‹ï¼š</div></pre></td></tr></table></figure></p>
<h1 id="sync-gunicorn-yml"><a href="#sync-gunicorn-yml" class="headerlink" title="./sync-gunicorn.yml"></a>./sync-gunicorn.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app_gunicorn:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-gunicorn<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - WORKERS=4
  - THREADS=50
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Let&apos;s build and start the server using 4 workers x 50 threads each (i.e. 200 threads in total):</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬ä½¿ç”¨ 4 ä¸ª workers x 50 ä¸ªçº¿ç¨‹ï¼ˆå³æ€»å…±200ä¸ªçº¿ç¨‹ï¼‰æ¥æ„å»ºå’Œå¯åŠ¨æœåŠ¡å™¨ï¼š</div></pre></td></tr></table></figure>
<h1 id="Build-and-start-app-served-by-Gunicorn"><a href="#Build-and-start-app-served-by-Gunicorn" class="headerlink" title="Build and start app served by Gunicorn"></a>Build and start app served by Gunicorn</h1><p>$ docker-compose -f sync-gunicorn.yml build<br>$ docker-compose -f sync-gunicorn.yml up<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Obviously, we expect a high number of requests being served concurrently:</div><div class="line"></div><div class="line">æ˜¾ç„¶ï¼Œæˆ‘ä»¬å¸Œæœ›åŒæ—¶å¤„ç†å¤§é‡è¯·æ±‚ï¼š</div></pre></td></tr></table></figure></p>
<p>$ ab -r -n 2000 -c 200 <a href="http://127.0.0.1:3000/?delay=1" target="_blank" rel="external">http://127.0.0.1:3000/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      200<br>Time taken for tests:   13.427 seconds<br>Complete requests:      2000<br>Failed requests:        0<br>Requests per second:    148.95 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">But if we compare the samples from top -H before and after the test, we can notice an interesting detail:</div><div class="line"></div><div class="line">ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬åœ¨æµ‹è¯•å‰åæ¯”è¾ƒ `top -H` çš„æ ·æœ¬ï¼Œæˆ‘ä»¬ä¼šæ³¨æ„åˆ°ä¸€ä¸ªæœ‰è¶£çš„ç»†èŠ‚ï¼š</div><div class="line"></div><div class="line">![deploy-gunicorn-before](https://iximiuz.com/flask-gevent-tutorial/deploy-gunicorn-before.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H(before test)`</div><div class="line"></div><div class="line">Gunicorn starts workers on the startup, but the workers spawn the threads on-demand:</div><div class="line"></div><div class="line">Gunicorn åœ¨å¯åŠ¨æ—¶å¯åŠ¨äº† workersï¼Œä½†æ˜¯ workers æŒ‰éœ€ç”Ÿæˆçº¿ç¨‹ï¼š</div><div class="line"></div><div class="line">![deploy-gunicorn-during](https://iximiuz.com/flask-gevent-tutorial/deploy-gunicorn-during.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (during test)`</div><div class="line"></div><div class="line">Now, let&apos;s switch to gevent workers. For this setup we need to make a new entrypoint to apply the monkey patching:</div><div class="line"></div><div class="line">ç°åœ¨ï¼Œè®©æˆ‘ä»¬åˆ‡æ¢åˆ° gevent workersã€‚è¿™ç§è®¾ç½®æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„å…¥å£ä»¥åº”ç”¨çŒ´å­è¡¥ä¸ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="flask-app-patched-py"><a href="#flask-app-patched-py" class="headerlink" title="./flask_app/patched.py"></a>./flask_app/patched.py</h1><p>from gevent import monkey<br>monkey.patch_all() # we need to patch very early</p>
<p>from app import app  # re-export<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">The Dockerfile to run Gunicorn + gevent:</div><div class="line"></div><div class="line">è¿è¡Œ Gunicorn + gevent çš„ Dockerfileï¼š</div></pre></td></tr></table></figure></p>
<h1 id="flask-app-Dockerfile-gevent-gunicorn"><a href="#flask-app-Dockerfile-gevent-gunicorn" class="headerlink" title="./flask_app/Dockerfile-gevent-gunicorn"></a>./flask_app/Dockerfile-gevent-gunicorn</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests gunicorn gevent</p>
<p>COPY app.py /app.py<br>COPY patched.py /patched.py</p>
<p>CMD gunicorn â€“worker-class gevent \<br>  â€“workers $WORKERS \<br>  â€“bind 0.0.0.0:$PORT_APP \<br>  patched:app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">The playground:</div><div class="line"></div><div class="line">æ¸¸ä¹åœºï¼š</div></pre></td></tr></table></figure></p>
<h1 id="async-gevent-gunicorn-yml"><a href="#async-gevent-gunicorn-yml" class="headerlink" title="./async-gevent-gunicorn.yml"></a>./async-gevent-gunicorn.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-gevent-gunicorn<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - WORKERS=1
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Let&apos;s start it:</div><div class="line"></div><div class="line">å¼€å§‹è¿è¡Œï¼š</div></pre></td></tr></table></figure>
<h1 id="Build-and-start-app-served-by-Gunicorn-gevent"><a href="#Build-and-start-app-served-by-Gunicorn-gevent" class="headerlink" title="Build and start app served by Gunicorn + gevent"></a>Build and start app served by Gunicorn + gevent</h1><p>$ docker-compose -f async-gevent-gunicorn.yml build<br>$ docker-compose -f async-gevent-gunicorn.yml up<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">And conduct the test:</div><div class="line"></div><div class="line">å¹¶è¿›è¡Œæµ‹è¯•ï¼š</div></pre></td></tr></table></figure></p>
<p>$ ab -r -n 2000 -c 200 <a href="http://127.0.0.1:3000/?delay=1" target="_blank" rel="external">http://127.0.0.1:3000/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      200<br>Time taken for tests:   17.839 seconds<br>Complete requests:      2000<br>Failed requests:        0<br>Requests per second:    112.11 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We observe similar behavior - only worker processes are alive before the test:</div><div class="line"></div><div class="line">æˆ‘ä»¬è§‚å¯Ÿåˆ°ç±»ä¼¼çš„è¡Œä¸º â€”â€” worker è¿›ç¨‹åªæœ‰åœ¨æµ‹è¯•ä¹‹å‰æ˜¯å¯ç”¨çš„ï¼š</div><div class="line"></div><div class="line">![deploy-gunicorn-gevent-before](https://iximiuz.com/flask-gevent-tutorial/deploy-gunicorn-gevent-before.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (before test)`</div><div class="line"></div><div class="line">But during the test, we see 10 new threads spawned. Notice, how it resembles the number of threads used by pywsgi:</div><div class="line"></div><div class="line">ä½†æ˜¯åœ¨æµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº§ç”Ÿäº†10ä¸ªæ–°çº¿ç¨‹ã€‚æ³¨æ„ï¼Œå®ƒä¸ä½¿ç”¨ pywsgi æ—¶çš„çº¿ç¨‹æ•°å¾ˆç›¸ä¼¼ã€‚</div><div class="line"></div><div class="line">![deploy-gunicorn-gevent-during](https://iximiuz.com/flask-gevent-tutorial/deploy-gunicorn-gevent-during.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (during test)`</div><div class="line"></div><div class="line"># 7. Deploy Flask application using uWSGI</div><div class="line"></div><div class="line"># 7. ä½¿ç”¨ uWSGI éƒ¨ç½² Flask åº”ç”¨</div><div class="line"></div><div class="line">uWSGI is a production-grade application server written in C. It&apos;s very fast and supports different execution models. Here we will again compare only two modes: synchronous (N worker processes x K threads each) and gevent-based (N worker processes x M async cores each).</div><div class="line"></div><div class="line">uWSGI æ˜¯ç”¨ C ç¼–å†™çš„ç”Ÿäº§çº§åº”ç”¨æœåŠ¡å™¨ã€‚å®ƒéå¸¸å¿«é€Ÿï¼Œå¹¶æ”¯æŒä¸åŒçš„æ‰§è¡Œæ¨¡å‹ã€‚ è¿™é‡Œæˆ‘ä»¬å°†å†æ¬¡ä»…æ¯”è¾ƒä¸¤ç§æ¨¡å¼ï¼šåŒæ­¥ï¼ˆN worker è¿›ç¨‹ x Kä¸ªçº¿ç¨‹ï¼‰å’ŒåŸºäº gevent çš„æ¨¡å¼ï¼ˆN workerè¿›ç¨‹ x Mä¸ªå¼‚æ­¥å†…æ ¸ï¼‰ã€‚</div><div class="line"></div><div class="line">First, the synchronous setup:</div><div class="line"></div><div class="line">é¦–å…ˆï¼ŒåŒæ­¥é…ç½®ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="flask-app-Dockerfile-uwsgi"><a href="#flask-app-Dockerfile-uwsgi" class="headerlink" title="./flask_app/Dockerfile-uwsgi"></a>./flask_app/Dockerfile-uwsgi</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests uwsgi</p>
<p>COPY app.py /app.py</p>
<p>CMD uwsgi â€“master \<br>  â€“workers $WORKERS \<br>  â€“threads $THREADS \<br>  â€“protocol $PROTOCOL \<br>  â€“socket 0.0.0.0:$PORT_APP \<br>  â€“module app:app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We use an extra parameters --protocol and the playground sets it to http:</div><div class="line"></div><div class="line">æˆ‘ä»¬ä½¿ç”¨é¢å¤–çš„å‚æ•°`--protocol`ï¼Œå¹¶ä¸”å°†æ¸¸ä¹åœºè®¾å®šä¸º`http:`</div></pre></td></tr></table></figure></p>
<h1 id="sync-uwsgi-yml"><a href="#sync-uwsgi-yml" class="headerlink" title="./sync-uwsgi.yml"></a>./sync-uwsgi.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app_uwsgi:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-uwsgi<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - WORKERS=4
  - THREADS=50
  - PROTOCOL=http
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We again limit the concurrency by 200 simultaneous HTTP requests (4 workers x 50 threads each):</div><div class="line"></div><div class="line">æˆ‘ä»¬å†æ¬¡å°†å¹¶å‘é™åˆ¶åˆ°åŒæ—¶å‘é€ 200 ä¸ª HTTP è¯·æ±‚ï¼ˆ4 workers x 50ä¸ªçº¿ç¨‹ï¼‰ï¼š</div></pre></td></tr></table></figure>
<h1 id="Build-and-start-app-served-by-uWSGI"><a href="#Build-and-start-app-served-by-uWSGI" class="headerlink" title="Build and start app served by uWSGI"></a>Build and start app served by uWSGI</h1><p>$ docker-compose -f sync-uwsgi.yml build<br>$ docker-compose -f sync-uwsgi.yml up<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Let&apos;s send a bunch of HTTP requests:</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬å‘é€ä¸€å †HTTPè¯·æ±‚ï¼š</div></pre></td></tr></table></figure></p>
<p>$ ab -r -n 2000 -c 200 <a href="http://127.0.0.1:3000/?delay=1" target="_blank" rel="external">http://127.0.0.1:3000/?delay=1</a></p>
<blockquote>
<p>Concurrency Level:      200<br>Time taken for tests:   12.685 seconds<br>Complete requests:      2000<br>Failed requests:        0<br>Requests per second:    157.67 [#/sec] (mean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uWSGI spaws workers and threads beforehand:</div><div class="line"></div><div class="line">uWSGI æå‰åˆ›å»ºäº† workers å’Œçº¿ç¨‹ï¼š</div><div class="line"></div><div class="line">![deploy-uwsgi-before](https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-before.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_uwsgi_1 top -H (before test)`</div><div class="line"></div><div class="line">So, only the load changes during the test:</div><div class="line"></div><div class="line">å› æ­¤ï¼Œåªæœ‰è´Ÿè½½åœ¨æµ‹è¯•æœŸé—´å‘ç”Ÿå˜åŒ–ï¼š</div><div class="line"></div><div class="line">![deploy-uwsgi-during](https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-during.png)</div><div class="line"></div><div class="line">`docker exec -it flask-gevent-tutorial_flask_app_uwsgi_1 top -H (during test)`</div><div class="line"></div><div class="line">Let&apos;s proceed to the gevent mode. We can reuse the patched.py entrypoint from the Gunicorn+gevent scenario:</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬è¿›å…¥ geven tæ¨¡å¼ã€‚ æˆ‘ä»¬å¯ä»¥é‡ç”¨åœ¨ Gunicorn + gevent åœºæ™¯ä¸­ä½¿ç”¨è¿‡çš„patched.py å…¥å£ï¼š</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="flask-app-Dockerfile-gevent-uwsgi"><a href="#flask-app-Dockerfile-gevent-uwsgi" class="headerlink" title="./flask_app/Dockerfile-gevent-uwsgi"></a>./flask_app/Dockerfile-gevent-uwsgi</h1><p>FROM python:3.8</p>
<p>RUN pip install Flask requests uwsgi gevent</p>
<p>COPY app.py /app.py<br>COPY patched.py /patched.py</p>
<p>CMD uwsgi â€“master \<br>  â€“single-interpreter \<br>  â€“workers $WORKERS \<br>  â€“gevent $ASYNC_CORES \<br>  â€“protocol $PROTOCOL \<br>  â€“socket 0.0.0.0:$PORT_APP \<br>  â€“module patched:app<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">One extra parameter the playground sets here is the number of async cores used by gevent:</div><div class="line"></div><div class="line">åœ¨è¿™é‡Œæ¸¸ä¹åœºè®¾ç½®çš„ä¸€ä¸ªé¢å¤–å‚æ•°æ˜¯ gevent ä½¿ç”¨çš„å¼‚æ­¥æ ¸å¿ƒæ•°ï¼š</div></pre></td></tr></table></figure></p>
<h1 id="async-gevent-uwsgi-yml"><a href="#async-gevent-uwsgi-yml" class="headerlink" title="./async-gevent-uwsgi.yml"></a>./async-gevent-uwsgi.yml</h1><p>version: â€œ3.7â€<br>services:<br>  flask_app:<br>    init: true<br>    build:<br>      context: ./flask_app<br>      dockerfile: Dockerfile-gevent-uwsgi<br>    environment:</p>
<pre><code>  - PORT_APP=3000
  - PORT_API=4000
  - WORKERS=2
  - ASYNC_CORES=2000
  - PROTOCOL=http
ports:
  - &quot;127.0.0.1:3000:3000&quot;
depends_on:
  - slow_api
</code></pre><p>  slow_api:<br>    init: true<br>    build: ./slow_api<br>    environment:</p>
<pre><code>  - PORT=4000
expose:
  - &quot;4000&quot;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Let&apos;s start the uWSGI+gevent server:</div><div class="line"></div><div class="line">è®©æˆ‘ä»¬å¯åŠ¨ uWSGI + gevent æœåŠ¡å™¨ï¼š</div><div class="line"></div><div class="line">```# Build and start app served by uWSGI + gevent</div><div class="line">$ docker-compose -f async-gevent-uwsgi.yml build</div><div class="line">$ docker-compose -f async-gevent-uwsgi.yml up</div></pre></td></tr></table></figure>
<p>And do the test:</p>
<p>å¹¶ä¸”è¿›è¡Œæµ‹è¯•ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1</div><div class="line">&gt; Time taken for tests:   13.164 seconds</div><div class="line">&gt; Complete requests:      2000</div><div class="line">&gt; Failed requests:        0</div><div class="line">&gt; Requests per second:    151.93 [#/sec] (mean)</div></pre></td></tr></table></figure>
<p>However, if we check the number of workers before and during the test we will notice a discrepancy with the previous method:</p>
<p>ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬æ£€æŸ¥åœ¨æµ‹è¯•ä¹‹å‰å’Œæµ‹è¯•æœŸé—´çš„ workers æ•°é‡ï¼Œæˆ‘ä»¬ä¼šå‘ç°ä¸ä¹‹å‰çš„æ–¹æ³•å­˜åœ¨å·®å¼‚ï¼š</p>
<p><img src="https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-gevent-before.png" alt="deploy-uwsgi-gevent-before"></p>
<p><code>docker exec -it flask-gevent-tutorial_flask_app_1 top -H (before test)</code></p>
<p>Before the test, uWSGI had the master and worker processes only, but during the test, threads were started, somewhat around 10 threads per worker process. This number resembles the numbers from gevent.pywsgi and Gunicorn+gevent cases:</p>
<p>åœ¨æµ‹è¯•ä¹‹å‰ï¼ŒuWSGIåªå…·æœ‰ä¸»è¿›ç¨‹å’Œ worker è¿›ç¨‹ï¼Œä½†æ˜¯åœ¨æµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œçº¿ç¨‹è¢«å¯åŠ¨äº†ï¼Œæ¯ä¸ª worker è¿›ç¨‹å¤§çº¦æœ‰10ä¸ªçº¿ç¨‹ã€‚è¿™ä¸ªæ•°ç›®ä¸ gevent.pywsgi å’Œ Gunicorn + gevent æ¡ˆä¾‹ä¸­çš„æ•°ç›®ç±»ä¼¼ï¼š</p>
<p><img src="https://iximiuz.com/flask-gevent-tutorial/deploy-uwsgi-gevent-during.png" alt="deploy-uwsgi-gevent-during"></p>
<p><code>docker exec -it flask-gevent-tutorial_flask_app_1 top -H (during test)</code></p>
<h1 id="8-Use-Nginx-reverse-proxy-in-front-of-application-server"><a href="#8-Use-Nginx-reverse-proxy-in-front-of-application-server" class="headerlink" title="8. Use Nginx reverse proxy in front of application server"></a>8. Use Nginx reverse proxy in front of application server</h1><h1 id="8-åœ¨åº”ç”¨æœåŠ¡å™¨å‰ä½¿ç”¨-Nginx-åå‘ä»£ç†"><a href="#8-åœ¨åº”ç”¨æœåŠ¡å™¨å‰ä½¿ç”¨-Nginx-åå‘ä»£ç†" class="headerlink" title="8. åœ¨åº”ç”¨æœåŠ¡å™¨å‰ä½¿ç”¨ Nginx åå‘ä»£ç†"></a>8. åœ¨åº”ç”¨æœåŠ¡å™¨å‰ä½¿ç”¨ Nginx åå‘ä»£ç†</h1><p>Usually, uWSGI and Gunicorn servers reside behind a load balancer and one of the most popular choices is Nginx.</p>
<p>é€šå¸¸ï¼ŒuWSGI å’Œ Gunicorn æœåŠ¡å™¨ä½äºè´Ÿè½½å‡è¡¡å™¨åé¢ï¼Œæœ€å—æ¬¢è¿çš„é€‰æ‹©ä¹‹ä¸€æ˜¯ Nginxã€‚</p>
<h2 id="8-1-Nginx-Gunicorn-gevent"><a href="#8-1-Nginx-Gunicorn-gevent" class="headerlink" title="8.1 Nginx + Gunicorn + gevent"></a>8.1 Nginx + Gunicorn + gevent</h2><p>Nginx configuration for Gunicorn upstream is just a standard proxy setup:</p>
<p>Gunicorn ä¸Šæ¸¸çš„ Nginx é…ç½®åªæ˜¯ä¸€ä¸ªæ ‡å‡†çš„ä»£ç†è®¾ç½®ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># ./flask_app/nginx-gunicorn.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_set_header Host $http_host;</div><div class="line">        proxy_set_header X-Real-IP $remote_addr;</div><div class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">        proxy_set_header X-Forwarded-Proto $scheme;</div><div class="line"></div><div class="line">        proxy_pass http://flask_app:3000;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>We can try it out using the following playground:</p>
<p>æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„æ¸¸ä¹åœºè¿›è¡Œå°è¯•ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"># ./nginx-gunicorn.yml</div><div class="line">version: &quot;3.7&quot;</div><div class="line">services:</div><div class="line">  ingress:</div><div class="line">    image: nginx:1.17.6</div><div class="line">    ports:</div><div class="line">      - &quot;127.0.0.1:8080:80&quot;</div><div class="line">    volumes:</div><div class="line">      - ./flask_app/nginx-gunicorn.conf:/etc/nginx/conf.d/default.conf</div><div class="line">    depends_on:</div><div class="line">      - flask_app</div><div class="line"></div><div class="line">  flask_app:</div><div class="line">    init: true</div><div class="line">    build:</div><div class="line">      context: ./flask_app</div><div class="line">      dockerfile: Dockerfile-gevent-gunicorn</div><div class="line">    environment:</div><div class="line">      - PORT_APP=3000</div><div class="line">      - PORT_API=4000</div><div class="line">      - WORKERS=1</div><div class="line">    expose:</div><div class="line">      - &quot;3000&quot;</div><div class="line">    depends_on:</div><div class="line">      - slow_api</div><div class="line"></div><div class="line">  slow_api:</div><div class="line">    init: true</div><div class="line">    build: ./slow_api</div><div class="line">    environment:</div><div class="line">      - PORT=4000</div><div class="line">    expose:</div><div class="line">      - &quot;4000&quot;</div></pre></td></tr></table></figure>
<p>And then:</p>
<p>ç„¶åï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker-compose -f nginx-gunicorn.yml build</div><div class="line">$ docker-compose -f nginx-gunicorn.yml up</div><div class="line"></div><div class="line">$ ab -r -n 2000 -c 200 http://127.0.0.1:8080/?delay=1</div><div class="line">&gt; ...</div></pre></td></tr></table></figure>
<h2 id="8-2-Nginx-uWSGI-gevent"><a href="#8-2-Nginx-uWSGI-gevent" class="headerlink" title="8.2 Nginx + uWSGI + gevent"></a>8.2 Nginx + uWSGI + gevent</h2><p>uWSGI setup is very similar, but there is a subtle improvement. uWSGI provides a special binary protocol (called uWSGI) to communicate with the reverse proxy in front of it. This makes the joint slightly more efficient. And Nginx kindly supports it:</p>
<p>uWSGI çš„è®¾ç½®éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯æœ‰ç»†å¾®çš„æ”¹è¿›ã€‚uWSGI æä¾›äº†ä¸€ç§ç‰¹æ®Šçš„äºŒè¿›åˆ¶åè®®ï¼ˆç§°ä¸ºuWSGIï¼‰ä¸å®ƒå‰é¢çš„åå‘ä»£ç†è¿›è¡Œé€šä¿¡ã€‚è¿™ä½¿å¾—å…³èŠ‚æ›´åŠ æœ‰æ•ˆã€‚Nginxå¯¹å®ƒçš„æ”¯æŒå‹å¥½ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ./flask_app/nginx-uwsgi.conf</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen 80;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        include uwsgi_params;</div><div class="line">        uwsgi_pass uwsgi://flask_app:3000;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Notice the environment variable PROTOCOL=uwsgi in the following playground:</p>
<p>è¯·æ³¨æ„ä¸‹é¢æ¸¸ä¹åœºä¸­çš„ç¯å¢ƒå˜é‡ <code>PROTOCOL = uwsgi</code>ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># ./nginx-uwsgi.yml</div><div class="line">version: &quot;3.7&quot;</div><div class="line">services:</div><div class="line">  ingress:</div><div class="line">    image: nginx:1.17.6</div><div class="line">    ports:</div><div class="line">      - &quot;127.0.0.1:8080:80&quot;</div><div class="line">    volumes:</div><div class="line">      - ./flask_app/nginx-uwsgi.conf:/etc/nginx/conf.d/default.conf</div><div class="line">    depends_on:</div><div class="line">      - flask_app</div><div class="line"></div><div class="line">  flask_app:</div><div class="line">    init: true</div><div class="line">    build:</div><div class="line">      context: ./flask_app</div><div class="line">      dockerfile: Dockerfile-gevent-uwsgi</div><div class="line">    environment:</div><div class="line">      - PORT_APP=3000</div><div class="line">      - PORT_API=4000</div><div class="line">      - WORKERS=1</div><div class="line">      - ASYNC_CORES=2000</div><div class="line">      - PROTOCOL=uwsgi</div><div class="line">    expose:</div><div class="line">      - &quot;3000&quot;</div><div class="line">    depends_on:</div><div class="line">      - slow_api</div><div class="line"></div><div class="line">  slow_api:</div><div class="line">    init: true</div><div class="line">    build: ./slow_api</div><div class="line">    environment:</div><div class="line">      - PORT=4000</div><div class="line">    expose:</div><div class="line">      - &quot;4000&quot;</div></pre></td></tr></table></figure>
<p>We can test the playground using:</p>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æµ‹è¯•æ¸¸ä¹åœºï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker-compose -f nginx-uwsgi.yml build</div><div class="line">$ docker-compose -f nginx-uwsgi.yml up</div><div class="line"></div><div class="line">$ ab -r -n 2000 -c 200 http://127.0.0.1:8080/?delay=1</div><div class="line">&gt; ...</div></pre></td></tr></table></figure>
<h1 id="9-Bonus-make-psycopg2-gevent-friendly-with-psycogreen"><a href="#9-Bonus-make-psycopg2-gevent-friendly-with-psycogreen" class="headerlink" title="9. Bonus: make psycopg2 gevent-friendly with psycogreen"></a>9. Bonus: make psycopg2 gevent-friendly with psycogreen</h1><h1 id="9-ç¦åˆ©ï¼šä½¿ç”¨-psycogreen-è®©-psycopg2-å˜å¾—-gevent-å‹å¥½"><a href="#9-ç¦åˆ©ï¼šä½¿ç”¨-psycogreen-è®©-psycopg2-å˜å¾—-gevent-å‹å¥½" class="headerlink" title="9. ç¦åˆ©ï¼šä½¿ç”¨ psycogreen è®© psycopg2 å˜å¾— gevent å‹å¥½"></a>9. ç¦åˆ©ï¼šä½¿ç”¨ psycogreen è®© psycopg2 å˜å¾— gevent å‹å¥½</h1><p>When asked, gevent patches only modules from the Python standard library. If we use 3rd party modules, like psycopg2, corresponding IO will remain blocking. Letâ€™s consider the following application:</p>
<p>gevent ä»…æ”¯æŒå¯¹ Python æ ‡å‡†åº“ä¸­çš„æ¨¡å—æ‰“è¡¥ä¸ã€‚å¦‚æœæˆ‘ä»¬ä½¿ç”¨ç¬¬ä¸‰æ–¹æ¨¡å—ï¼ˆä¾‹å¦‚psycopg2ï¼‰ï¼Œåˆ™ç›¸åº”çš„IOå°†ä¿æŒé˜»å¡çŠ¶æ€ã€‚ è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹åº”ç”¨ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># ./psycopg2/app.py</div><div class="line"></div><div class="line">from gevent import monkey</div><div class="line">monkey.patch_all()</div><div class="line"></div><div class="line">import os</div><div class="line"></div><div class="line">import psycopg2</div><div class="line">import requests</div><div class="line">from flask import Flask, request</div><div class="line"></div><div class="line">api_port = os.environ[&apos;PORT_API&apos;]</div><div class="line">api_url = f&apos;http://slow_api:&#123;api_port&#125;/&apos;</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    conn = psycopg2.connect(user=&quot;example&quot;, password=&quot;example&quot;, host=&quot;postgres&quot;)</div><div class="line">    delay = float(request.args.get(&apos;delay&apos;) or 1)</div><div class="line">    resp = requests.get(f&apos;&#123;api_url&#125;?delay=&#123;delay/2&#125;&apos;)</div><div class="line"></div><div class="line">    cur = conn.cursor()</div><div class="line">    cur.execute(&quot;SELECT NOW(), pg_sleep(%s)&quot;, (delay/2,))</div><div class="line"></div><div class="line">    return &apos;Hi there! &#123;&#125; &#123;&#125;&apos;.format(resp.text, cur.fetchall()[0])</div></pre></td></tr></table></figure>
<p>We extended the workload by adding intentionally slow database access. Letâ€™s prepare the Dockerfile:</p>
<p>é€šè¿‡æœ‰æ„åœ°æ·»åŠ æ•°æ®åº“æ…¢è®¿é—®ï¼Œæˆ‘ä»¬å¢åŠ äº†å·¥ä½œè´Ÿè½½ã€‚è®©æˆ‘ä»¬å‡†å¤‡ Dockerfileï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"># ./psycopg2/Dockerfile</div><div class="line">FROM python:3.8</div><div class="line"></div><div class="line">RUN pip install Flask requests psycopg2 psycogreen uwsgi gevent</div><div class="line"></div><div class="line">COPY app.py /app.py</div><div class="line">COPY patched.py /patched.py</div><div class="line"></div><div class="line">CMD uwsgi --master \</div><div class="line">  --single-interpreter \</div><div class="line">  --workers $WORKERS \</div><div class="line">  --gevent $ASYNC_CORES \</div><div class="line">  --protocol http \</div><div class="line">  --socket 0.0.0.0:$PORT_APP \</div><div class="line">  --module $MODULE:app</div></pre></td></tr></table></figure>
<p>And the playground:</p>
<p>æ¸¸ä¹åœºï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"># ./bonus-psycopg2-gevent.yml</div><div class="line">version: &quot;3.7&quot;</div><div class="line">services:</div><div class="line">  flask_app:</div><div class="line">    init: true</div><div class="line">    build:</div><div class="line">      context: ./psycopg2</div><div class="line">      dockerfile: Dockerfile</div><div class="line">    environment:</div><div class="line">      - PORT_APP=3000</div><div class="line">      - PORT_API=4000</div><div class="line">      - WORKERS=1</div><div class="line">      - ASYNC_CORES=2000</div><div class="line">      - MODULE=app</div><div class="line">    ports:</div><div class="line">      - &quot;127.0.0.1:3000:3000&quot;</div><div class="line">    depends_on:</div><div class="line">      - slow_api</div><div class="line">      - postgres</div><div class="line"></div><div class="line">  slow_api:</div><div class="line">    init: true</div><div class="line">    build: ./slow_api</div><div class="line">    environment:</div><div class="line">      - PORT=4000</div><div class="line">    expose:</div><div class="line">      - &quot;4000&quot;</div><div class="line"></div><div class="line">  postgres:</div><div class="line">    image: postgres</div><div class="line">    environment:</div><div class="line">      POSTGRES_USER: example</div><div class="line">      POSTGRES_PASSWORD: example</div><div class="line">    expose:</div><div class="line">      - &quot;5432&quot;</div></pre></td></tr></table></figure>
<p>Ideally, we expect ~2 seconds to perform 10 one-second-long HTTP requests with concurrency 5. But the test shows more than 6 seconds due to the blocking behavior of psycopg2 calls:</p>
<p>ç†æƒ³æƒ…å†µä¸‹ï¼Œåœ¨å¹¶å‘ä¸º5æ—¶ï¼Œæˆ‘ä»¬æœŸæœ›ä½¿ç”¨çº¦2ç§’çš„æ—¶é—´æ¥æ‰§è¡Œ10ä¸ªä¸€ç§’é•¿çš„HTTPè¯·æ±‚ã€‚ä½†æ˜¯ç”±äº psycopg2 è°ƒç”¨çš„é˜»å¡è¡Œä¸ºï¼Œè¯¥æµ‹è¯•æ˜¾ç¤ºäº†è¶…è¿‡6ç§’çš„æ—¶é—´ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker-compose -f bonus-psycopg2-gevent.yml build</div><div class="line">$ docker-compose -f bonus-psycopg2-gevent.yml up</div><div class="line"></div><div class="line">$ ab -r -n 10 -c 5 http://127.0.0.1:3000/?delay=1</div><div class="line">&gt; Concurrency Level:      5</div><div class="line">&gt; Time taken for tests:   6.670 seconds</div><div class="line">&gt; Complete requests:      10</div><div class="line">&gt; Failed requests:        0</div><div class="line">&gt; Requests per second:    1.50 [#/sec] (mean)</div></pre></td></tr></table></figure>
<p>To bypass this limitation, we need to use psycogreen module to patch psycopg2:</p>
<p>è¦ç»•è¿‡æ­¤é™åˆ¶ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ psycogreen æ¨¡å—æ¥ç»™ psycopg2 æ‰“è¡¥ä¸ï¼š</p>
<p>The psycogreen package enables psycopg2 to work with coroutine libraries, using asynchronous calls internally but offering a blocking interface so that regular code can run unmodified. Psycopg offers coroutines support since release 2.2. Because the main module is a C extension it cannot be monkey-patched to become coroutine-friendly. Instead it exposes a hook that coroutine libraries can use to install a function integrating with their event scheduler. Psycopg will call the function whenever it executes a libpq call that may block. psycogreen is a collection of â€œwait callbacksâ€ useful to integrate Psycopg with different coroutine libraries.</p>
<p>psycogreen è½¯ä»¶åŒ…ä½¿ psycopg2 èƒ½å¤Ÿä¸åç¨‹åº“ä¸€èµ·ä½¿ç”¨ï¼Œåœ¨å†…éƒ¨ä½¿ç”¨å¼‚æ­¥è°ƒç”¨ï¼Œä½†æä¾›äº†é˜»å¡æ¥å£ï¼Œå› æ­¤å¸¸è§„ä»£ç å¯ä»¥åœ¨æœªä¿®æ”¹çš„æƒ…å†µä¸‹è¿è¡Œã€‚è‡ªç‰ˆæœ¬ 2.2 èµ·ï¼ŒPsycopg æä¾›åç¨‹æ”¯æŒã€‚ ç”±äºä¸»æ¨¡å—æ˜¯ C æ‰©å±•ï¼Œå› æ­¤æ— æ³•å¯¹å…¶æ‰“çŒ´å­è¡¥ä¸æ¥æˆä¸ºåç¨‹å‹å¥½çš„ã€‚ç›¸åï¼Œå®ƒæš´éœ²äº†ä¸€ä¸ªé’©å­ï¼Œåç¨‹åº“å¯ä½¿ç”¨è¯¥é’©å­æ¥å®‰è£…ä¸å…¶äº‹ä»¶è°ƒåº¦ç¨‹åºé›†æˆçš„å‡½æ•°ã€‚åªè¦ Psycopg æ‰§è¡Œå¯èƒ½é˜»å¡çš„libpq è°ƒç”¨ï¼Œå®ƒå°†è°ƒç”¨è¯¥å‡½æ•°ã€‚psycogreen æ˜¯â€œç­‰å¾…å›è°ƒâ€çš„é›†åˆï¼Œå¯ç”¨äºå°† Psycopg ä¸ä¸åŒçš„åç¨‹åº“é›†æˆåœ¨ä¸€èµ·ã€‚</p>
<p>Letâ€™s create an entrypoint:</p>
<p>è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå…¥å£ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># ./psycopg2/patched.py</div><div class="line">from psycogreen.gevent import patch_psycopg</div><div class="line">patch_psycopg()</div><div class="line"></div><div class="line">from app import app  # re-export</div></pre></td></tr></table></figure>
<p>And extend the playground:</p>
<p>æ‰©å±•æ¸¸ä¹åœºï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># ./bonus-psycopg2-gevent.yml</div><div class="line"></div><div class="line">services:</div><div class="line">  # ...</div><div class="line"></div><div class="line">  flask_app_2:</div><div class="line">    init: true</div><div class="line">    build:</div><div class="line">      context: ./psycopg2</div><div class="line">      dockerfile: Dockerfile</div><div class="line">    environment:</div><div class="line">      - PORT_APP=3001</div><div class="line">      - PORT_API=4000</div><div class="line">      - WORKERS=1</div><div class="line">      - ASYNC_CORES=2000</div><div class="line">      - MODULE=patched</div><div class="line">    ports:</div><div class="line">      - &quot;127.0.0.1:3001:3001&quot;</div><div class="line">    depends_on:</div><div class="line">      - slow_api</div><div class="line">      - postgres</div></pre></td></tr></table></figure>
<p>If we test the new instance of the application with ab -n 10 -c 5, the observed performance will be much close to the theoretical one:</p>
<p>å¦‚æœæˆ‘ä»¬ä½¿ç”¨ <code>ab -n 10 -c 5</code> æµ‹è¯•åº”ç”¨çš„æ–°å®ä¾‹ï¼Œå¯ä»¥è§‚å¯Ÿåˆ°å…¶æ€§èƒ½å°†éå¸¸æ¥è¿‘ç†è®ºå€¼ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker-compose -f bonus-psycopg2-gevent.yml build</div><div class="line">$ docker-compose -f bonus-psycopg2-gevent.yml up</div><div class="line"></div><div class="line">$ ab -r -n 10 -c 5 http://127.0.0.1:3001/?delay=1</div><div class="line">&gt; Concurrency Level:      5</div><div class="line">&gt; Time taken for tests:   3.148 seconds</div><div class="line">&gt; Complete requests:      10</div><div class="line">&gt; Failed requests:        0</div><div class="line">&gt; Requests per second:    3.18 [#/sec] (mean)</div></pre></td></tr></table></figure>
<h1 id="10-Instead-of-conclusion"><a href="#10-Instead-of-conclusion" class="headerlink" title="10. Instead of conclusion"></a>10. Instead of conclusion</h1><h1 id="10-ä¸æ˜¯ç»“è®ºçš„ç»“è®º"><a href="#10-ä¸æ˜¯ç»“è®ºçš„ç»“è®º" class="headerlink" title="10. ä¸æ˜¯ç»“è®ºçš„ç»“è®º"></a>10. ä¸æ˜¯ç»“è®ºçš„ç»“è®º</h1><p>Make code, not war!</p>
<p>ç¼–å†™ä»£ç ï¼Œè€Œä¸æ˜¯æˆ˜äº‰ï¼</p>
<h1 id="11-Related-articles"><a href="#11-Related-articles" class="headerlink" title="11. Related articles"></a>11. Related articles</h1><h1 id="11-ç›¸å…³æ–‡ç« "><a href="#11-ç›¸å…³æ–‡ç« " class="headerlink" title="11. ç›¸å…³æ–‡ç« "></a>11. ç›¸å…³æ–‡ç« </h1><p>Save the day with gevent</p>
<p>é‚£å¤© gevent æ‹¯æ•‘äº†æˆ‘ä»¬</p>
<p>python,flask,gevent,asyncio,uwsgi,gunicorn,nginx</p>
<p>Written by Ivan Velichko</p>
<p>Follow me on twitter @iximiuz</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://clampist.github.io/2020/01/04/å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) /" data-id="ck5chebey00bfqyqma29zwat0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/06/mysql_distinct_count_group_by/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          mysql distinct count group by
        
      </div>
    </a>
  
  
    <a href="/2018/12/21/leetcode-subarray-sum-equals-k/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Subarray Sum Equals K</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">åˆ†ç±»</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bigflow/">bigflow</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cpp/">cpp</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/django/">django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/json/">json</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/opencv/">opencv</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">æ ‡ç­¾</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/2d-array/">2d-array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bigflow/">bigflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binary-tree/">binary tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/">lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3/">python3</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">æ ‡ç­¾äº‘</h3>
    <div class="widget tagcloud">
      <a href="/tags/2d-array/" style="font-size: 12px;">2d-array</a> <a href="/tags/bigflow/" style="font-size: 10px;">bigflow</a> <a href="/tags/binary-tree/" style="font-size: 14px;">binary tree</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/python/" style="font-size: 16px;">python</a> <a href="/tags/python3/" style="font-size: 18px;">python3</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">å½’æ¡£</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">ä¸€æœˆ 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">åäºŒæœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">åä¸€æœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">åæœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">ä¹æœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">å…«æœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">ä¸‰æœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">äºŒæœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">ä¸€æœˆ 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">åä¸€æœˆ 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">åæœˆ 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">ä¹æœˆ 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">å››æœˆ 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">äºŒæœˆ 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">åä¸€æœˆ 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/10/">åæœˆ 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">æœ€æ–°æ–‡ç« </h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/06/python-requests-timeout-try-expect/">Python requests è¶…æ—¶ å¼‚å¸¸æ•æ‰</a>
          </li>
        
          <li>
            <a href="/2020/01/06/mysql_distinct_count_group_by/">mysql distinct count group by</a>
          </li>
        
          <li>
            <a href="/2020/01/04/å¦‚ä½•åœ¨ Flask ä¸­ä½¿ç”¨ gevent (uWSGI + Gunicorn ç‰ˆæœ¬) /">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/12/21/leetcode-subarray-sum-equals-k/">Subarray Sum Equals K</a>
          </li>
        
          <li>
            <a href="/2018/12/20/leetcode-path-sum-iii/">Path Sum III</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Krevy Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>